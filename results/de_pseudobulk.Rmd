---
title: "de_pseudobulk"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Libraries
```

Pseudobulk approach for testing differential expression between conditions:
http://bioconductor.org/books/3.14/OSCA.multisample/multi-sample-comparisons.html


Why I'm using the pseudobulk approach:
- Use replicate information
Other reasons provided by the tutorial:
- Summing counts across clusters, gets higher counts, easier to do stats, esp. with already established methods for bulk RNA seq 
- Biological rep at sample level, not at cell level
- They say mask helps with not penalizing DEGs with high intra cluster variance, but I am not sure if I agree with this.

First I want to follow the tutorial and later will try with experimental data. 
Note that the tutorial dataset is similar to what we are working with.
Description of the Pijuan-Sala et al. 2019 dataset:

"Each chimeric embryo was generated by injecting td-Tomato-positive embryonic stem cells (ESCs) into a wild-type (WT) blastocyst.[..] the aim of this “wild-type chimera” study is to determine whether the injection procedure itself introduces differences in lineage commitment compared to the background cells." 

"each batch contains one sample consisting of td-Tomato positive cells and another consisting of negative cells, obtained by fluorescence-activated cell sorting from a single pool of dissociated cells from 6-7 chimeric embryos"

First they get the integrated dataset from code they explain in a different tutorial:
```{r eval = FALSE}
#--- loading ---#
library(MouseGastrulationData)
sce.chimera <- WTChimeraData(samples=5:10)


#--- feature-annotation ---#
library(scater)
rownames(sce.chimera) <- uniquifyFeatureNames(
    rowData(sce.chimera)$ENSEMBL, rowData(sce.chimera)$SYMBOL)

#--- quality-control ---#
drop <- sce.chimera$celltype.mapped %in% c("stripped", "Doublet")
sce.chimera <- sce.chimera[,!drop]

#--- normalization ---#
sce.chimera <- logNormCounts(sce.chimera)

#--- variance-modelling ---#
library(scran)
dec.chimera <- modelGeneVar(sce.chimera, block=sce.chimera$sample)
chosen.hvgs <- dec.chimera$bio > 0

#--- merging ---#
library(batchelor)
set.seed(01001001)
merged <- correctExperiments(sce.chimera, 
    batch=sce.chimera$sample, 
    subset.row=chosen.hvgs,
    PARAM=FastMnnParam(
        merge.order=list(
            list(1,3,5), # WT (3 replicates)
            list(2,4,6)  # td-Tomato (3 replicates)
        )
    )
)

#--- clustering ---#
g <- buildSNNGraph(merged, use.dimred="corrected")
clusters <- igraph::cluster_louvain(g)
colLabels(merged) <- factor(clusters$membership)

#--- dimensionality-reduction ---#
merged <- runTSNE(merged, dimred="corrected", external_neighbors=TRUE)
merged <- runUMAP(merged, dimred="corrected", external_neighbors=TRUE)

saveRDS(merged, file = "../data_output/mouse_gastru_merged.rds")
```

```{r}
merged <- readRDS("../data_output/mouse_gastru_merged.rds")
```


```{r}
merged
```

Aggregate cells per cluster to get pseudobulk.

```{r}
# Using 'label' and 'sample' as our two factors; each column of the output
# corresponds to one unique combination of these two factors.
summed <- aggregateAcrossCells(merged, 
    id=colData(merged)[,c("celltype.mapped", "sample")])
summed

```


Then they do the DE test with edgeR

```{r}
label <- "Mesenchyme" # They choose a single cluster here
current <- summed[,label==summed$celltype.mapped]

# Creating up a DGEList object for use in edgeR:
library(edgeR)
y <- DGEList(counts(current), samples=colData(current))
# Filter low abundance 
discarded <- current$ncells < 10
y <- y[,!discarded]
keep <- filterByExpr(y, group=current$tomato)
y <- y[keep,]

# Correction for composition and library size biases
y <- calcNormFactors(y)

# Design matrix
design <- model.matrix(~factor(pool) + factor(tomato), y$samples)
# Estimate dipersions
y <- estimateDisp(y, design)
# Fit model
fit <- glmQLFit(y, design, robust=TRUE)
# Test coefficients
res <- glmQLFTest(fit, coef=ncol(design))

summary(decideTests(res))

```

Next they do this for all clusters / cell types:
```{r}
summed.filt <- summed[,summed$ncells >= 10]

de.results <- pseudoBulkDGE(summed.filt, 
    label=summed.filt$celltype.mapped,
    design=~factor(pool) + tomato,
    coef="tomatoTRUE",
    condition=summed.filt$tomato 
)

cur.results <- de.results$`Forebrain/Midbrain/Hindbrain`
cur.results[order(cur.results$PValue),]

```

Some tests were skipped due to either absence of replicates or contrasts (?)
```{r}
metadata(de.results)$failed
```

Cross level meta analysis

This is what I was wondering about because you go from doing experiment vs control to doing exp vs ctrl x number of cell types. So is there a need to control for multiple testing because of this? 

And the other thing is to find genes that are DE in only a certain cell type.


DE genes per label (NA is removed due to low abundance / low expression):
```{r}
is.de <- decideTestsPerLabel(de.results, threshold=0.05)
summarizeTestsPerLabel(is.de)
sort(rowSums(is.de > 0 & !is.na(is.de)), decreasing = TRUE) %>%
  tibble::enframe() %>%
  dplyr::filter(value > 0) %>%
  ggplot(aes(1:nrow(.), value)) +
  geom_point()

sort(rowSums(is.de < 0 & !is.na(is.de)), decreasing = TRUE) %>%
  tibble::enframe() %>%
  dplyr::filter(value > 0) %>%
  ggplot(aes(1:nrow(.), value)) +
  geom_point()

```

Identify cell type specific DEs. 

Ok, so far it's all been wrapping edgeR. But this step introduces a new statistical test where the null hypothesis is:

"the null hypothesis for each label and gene is that the log-fold change lies between zero and the average log-fold change of the other labels"

```{r}
de.specific <- pseudoBulkSpecific(summed.filt,
    label=summed.filt$celltype.mapped,
    design=~factor(pool) + tomato,
    coef="tomatoTRUE",
    condition=summed.filt$tomato
)

cur.specific <- de.specific[["Allantois"]]
cur.specific <- cur.specific[order(cur.specific$PValue),]
cur.specific

```

```{r}
sizeFactors(summed.filt) <- NULL
plotExpression(logNormCounts(summed.filt),
    features="Xist",
    x="tomato", colour_by="tomato",
    other_fields="celltype.mapped") +
    facet_wrap(~celltype.mapped)

```

These are genes that are "not DE expressed" in other cell types:
significant in label of interest, but > 0.5 FDR in other labels.
```{r}
# Finding all genes that are not remotely DE in all other labels.
remotely.de <- decideTestsPerLabel(de.results, threshold=0.5)
not.de <- remotely.de==0 | is.na(remotely.de)
not.de.other <- rowMeans(not.de[,colnames(not.de)!="Allantois"])==1

# Intersecting with genes that are DE inthe allantois.
unique.degs <- is.de[,"Allantois"]!=0 & not.de.other
unique.degs <- names(which(unique.degs))

# Inspecting the results.
de.allantois <- de.results$Allantois
de.allantois <- de.allantois[unique.degs,]
de.allantois <- de.allantois[order(de.allantois$PValue),]
de.allantois

```

```{r}
plotExpression(logNormCounts(summed.filt), 
    features="Rbp4",
    x="tomato", colour_by="tomato", 
    other_fields="celltype.mapped") + 
    facet_wrap(~celltype.mapped)

```


An inverse approach is to identify DE between clusters, but using actual replicates instead of cells as replicates.

```{r}
summed.sub <- summed[,summed$celltype.mapped %in% c("Neural crest", "Notochord")]
# Using a dummy value for the label to allow us to include multiple cell types
# in the fitted model; otherwise, each cell type will be processed separately.
between.res <- pseudoBulkDGE(summed.sub,
    label=rep("dummy", ncol(summed.sub)),
    design=~factor(sample) + celltype.mapped,
    coef="celltype.mappedNotochord")[[1]]


table(Sig=between.res$FDR <= 0.05, Sign=sign(between.res$logFC))

```


```{r eval = FALSE}
sizeFactors(summed.sub) <- NULL

summed.sub <- logNormCounts(summed.sub, size.factors=NULL)

plotExpression(summed.sub, 
    features=head(rownames(between.res)[order(between.res$PValue)]),
    x="celltype.mapped", 
    colour_by=I(factor(summed.sub$sample)))

```

There is some discussion in the tutorial about how depending on how the labels were obtained, whether it makes sense to get DEs. Because cell types came from clustering, we expect that some of the genes will be DE. I see this as analogous to FindMarkers, but does the same p-value not meaningful thing applies here, even when we are using biological replicates?

Another question that  might make more sense is to get those genes that are DE between clusters but that change in the condition. So like an interaction between cell type and condition. 
```{r}
inter.res <- pseudoBulkDGE(summed.sub,
    label=rep("dummy", ncol(summed.sub)),
    design=function(df) {
        combined <- with(df, paste0(tomato, ".", celltype.mapped))
        combined <- make.names(combined)
        design <- model.matrix(~0 + factor(sample) + combined, df)
        design[,!grepl("Notochord", colnames(design))]
    },
    coef="combinedTRUE.Neural.crest"
)[[1]]

table(Sig=inter.res$FDR <= 0.05, Sign=sign(inter.res$logFC))

```


